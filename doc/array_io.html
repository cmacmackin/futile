<HTML>
<HEAD>
   <TITLE> module array_io (generated by f90doc) </TITLE>
</HEAD>
<H1> Module array_io </H1>
<PRE>module array_io

        ! Variables
    character, private :: <A HREF="array_io.html#var_com_char">com_char</A> = '#'
    character (len=64), private, parameter :: <A HREF="array_io.html#var_allocate_err">allocate_err</A> = '("ARRAY_IO: Array already allocated and NOCLOBBER specified.")'
    character (len=64), private, parameter :: <A HREF="array_io.html#var_empty_err">empty_err</A> = '("ARRAY_IO: No data in file ",a,".")'
    character (len=64), private, parameter :: <A HREF="array_io.html#var_open_err">open_err</A> = '("ARRAY_IO: Problem when opening file. Error code ",I0,".")'
    character (len=64), private, parameter :: <A HREF="array_io.html#var_read_err">read_err</A> = '("ARRAY_IO: Problem reading from file. Error code ",I0,".")'
    character (len=64), private, parameter :: <A HREF="array_io.html#var_write_err">write_err</A> = '("ARRAY_IO: Problem writing to file. Error code ",I0,".")'
    character (len=128), private, parameter :: <A HREF="array_io.html#var_clob_err">clob_err</A> = '("ARRAY_IO: Unrecognized CLOBBER specification. Please select ''clobber'',",/,"ARRAY_IO: ''noclobber'', or ''append''.")'
    integer, private, parameter :: <A HREF="array_io.html#var_io_unit">io_unit</A> = 90
    integer, private, parameter :: <A HREF="array_io.html#var_line_len">line_len</A> = 1024
    integer, private, parameter :: <A HREF="array_io.html#var_stderr">stderr</A> = 0
    integer, private, parameter :: <A HREF="array_io.html#var_stdin">stdin</A> = 5
    integer, private, parameter :: <A HREF="array_io.html#var_stdout">stdout</A> = 6

        ! Interfaces
    public interface <A HREF="array_io.html#interface_loadtxt">loadtxt</A>
    public interface <A HREF="array_io.html#interface_savetxt">savetxt</A>

        ! Subroutines and functions
    public subroutine <A HREF="array_io.html#subroutine_file_size">file_size</A> (nrows, ncols)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_i1">loadtxt_dynamic_i1</A> (filename, i1array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_i2">loadtxt_dynamic_i2</A> (filename, i2array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_i4">loadtxt_dynamic_i4</A> (filename, i4array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_i8">loadtxt_dynamic_i8</A> (filename, i8array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_r4">loadtxt_dynamic_r4</A> (filename, r4array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_r8">loadtxt_dynamic_r8</A> (filename, r8array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_dynamic_r16">loadtxt_dynamic_r16</A> (filename, r16array_dyn, clobber, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_i1">loadtxt_static_i1</A> (filename, i1array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_i2">loadtxt_static_i2</A> (filename, i2array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_i4">loadtxt_static_i4</A> (filename, i4array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_i8">loadtxt_static_i8</A> (filename, i8array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_r4">loadtxt_static_r4</A> (filename, r4array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_r8">loadtxt_static_r8</A> (filename, r8array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_loadtxt_static_r16">loadtxt_static_r16</A> (filename, r16array, nrows, errval)
    private subroutine <A HREF="array_io.html#subroutine_set_comment">set_comment</A> (com)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_i1">savetxt_i1</A> (filename, i1array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_i2">savetxt_i2</A> (filename, i2array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_i4">savetxt_i4</A> (filename, i4array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_i8">savetxt_i8</A> (filename, i8array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_r4">savetxt_r4</A> (filename, r4array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_r8">savetxt_r8</A> (filename, r8array, clobber, user_format, errval)
    private subroutine <A HREF="array_io.html#subroutine_savetxt_r16">savetxt_r16</A> (filename, r16array, clobber, user_format, errval)

end module array_io
</PRE>
  Provides subroutines to easily perform array input and output. They are 
  modelled after the "loadtxt" and "savetxt" subroutines in Numpy. Note: if 
  using this module, do not use logical unit 90 for any IO, as it is reserved 
  for use by these subroutines. Lines in the file beginning with the pound 
  symbol (#) are considered comments and will not be read. The comment 
  character can be changed using the set_comment() command. Works for both 
  integer and real data. Complex data IO has not yet been properly 
  implemented.
<P>
<STRONG>Author:</STRONG> Chris MacMackin

<HR><H2> Description of Variables </H2>
<A NAME="var_com_char"><H3>com_char</H3></A>
<PRE>character, private :: com_char = '#'
</PRE>
<A NAME="var_allocate_err"><H3>allocate_err</H3></A>
<PRE>character (len=64), private, parameter :: allocate_err = '("ARRAY_IO: Array already allocated and NOCLOBBER specified.")'
</PRE>
<A NAME="var_empty_err"><H3>empty_err</H3></A>
<PRE>character (len=64), private, parameter :: empty_err = '("ARRAY_IO: No data in file ",a,".")'
</PRE>
<A NAME="var_open_err"><H3>open_err</H3></A>
<PRE>character (len=64), private, parameter :: open_err = '("ARRAY_IO: Problem when opening file. Error code ",I0,".")'
</PRE>
<A NAME="var_read_err"><H3>read_err</H3></A>
<PRE>character (len=64), private, parameter :: read_err = '("ARRAY_IO: Problem reading from file. Error code ",I0,".")'
</PRE>
<A NAME="var_write_err"><H3>write_err</H3></A>
<PRE>character (len=64), private, parameter :: write_err = '("ARRAY_IO: Problem writing to file. Error code ",I0,".")'
</PRE>
<A NAME="var_clob_err"><H3>clob_err</H3></A>
<PRE>character (len=128), private, parameter :: clob_err = '("ARRAY_IO: Unrecognized CLOBBER specification. Please select ''clobber'',",/,"ARRAY_IO: ''noclobber'', or ''append''.")'
</PRE>
<A NAME="var_io_unit"><H3>io_unit</H3></A>
<PRE>integer, private, parameter :: io_unit = 90
</PRE>
<A NAME="var_line_len"><H3>line_len</H3></A>
<PRE>integer, private, parameter :: line_len = 1024
</PRE>
<A NAME="var_stderr"><H3>stderr</H3></A>
<PRE>integer, private, parameter :: stderr = 0
</PRE>
<A NAME="var_stdin"><H3>stdin</H3></A>
<PRE>integer, private, parameter :: stdin = 5
</PRE>
<A NAME="var_stdout"><H3>stdout</H3></A>
<PRE>integer, private, parameter :: stdout = 6
</PRE>

<HR><H2> Description of Interfaces </H2>
<A NAME="interface_loadtxt"><H3>loadtxt</H3></A>
<PRE>public interface loadtxt
    module procedure <A HREF="#subroutine_loadtxt_dynamic_i1">loadtxt_dynamic_i1</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_i2">loadtxt_dynamic_i2</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_i4">loadtxt_dynamic_i4</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_i8">loadtxt_dynamic_i8</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_r4">loadtxt_dynamic_r4</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_r8">loadtxt_dynamic_r8</A>
    module procedure <A HREF="#subroutine_loadtxt_dynamic_r16">loadtxt_dynamic_r16</A>
    module procedure <A HREF="#subroutine_loadtxt_static_i1">loadtxt_static_i1</A>
    module procedure <A HREF="#subroutine_loadtxt_static_i2">loadtxt_static_i2</A>
    module procedure <A HREF="#subroutine_loadtxt_static_i4">loadtxt_static_i4</A>
    module procedure <A HREF="#subroutine_loadtxt_static_i8">loadtxt_static_i8</A>
    module procedure <A HREF="#subroutine_loadtxt_static_r4">loadtxt_static_r4</A>
    module procedure <A HREF="#subroutine_loadtxt_static_r8">loadtxt_static_r8</A>
    module procedure <A HREF="#subroutine_loadtxt_static_r16">loadtxt_static_r16</A>
end interface loadtxt
</PRE>
 Loads arrays from text files into an array. Can work with one, two, four,
 and eight byte integer data and with four, eight, and sixteen byte real 
 data.
<A NAME="interface_savetxt"><H3>savetxt</H3></A>
<PRE>public interface savetxt
    module procedure <A HREF="#subroutine_savetxt_i1">savetxt_i1</A>
    module procedure <A HREF="#subroutine_savetxt_i2">savetxt_i2</A>
    module procedure <A HREF="#subroutine_savetxt_i4">savetxt_i4</A>
    module procedure <A HREF="#subroutine_savetxt_i8">savetxt_i8</A>
    module procedure <A HREF="#subroutine_savetxt_r4">savetxt_r4</A>
    module procedure <A HREF="#subroutine_savetxt_r8">savetxt_r8</A>
    module procedure <A HREF="#subroutine_savetxt_r16">savetxt_r16</A>
end interface savetxt
</PRE>
 Write quantities from an array to a text file. Can work with one, two, 
 four, and eight byte integer data and with four, eight, and sixteen  
 byte real data.

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_file_size"><H3>file_size</H3></A>
<PRE>public subroutine file_size (nrows, ncols)
    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data present in the file. An empty 
 row is interpreted as the end of the file.
</DL></DL>
<PRE>    integer, intent(out) :: ncols
</PRE>
<DL><DD><DL><DD>
 The number of columns of data present. This is determined from the 
 number of pieces of data in first row. Each datum must be separated 
 by white-space.
</DL></DL>
<PRE>end subroutine file_size
</PRE>
  Finds the amount of data in whatever file is currently associated with 
  IO unit 90. Doesn't count lines with no data or entirely commented out.
<A NAME="subroutine_loadtxt_dynamic_i1"><H3>loadtxt_dynamic_i1</H3></A>
<PRE>private subroutine loadtxt_dynamic_i1 (filename, i1array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    integer (kind=int8), allocatable, dimension(:,:), intent(inout) :: i1array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file. 
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber'  
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_i1
</PRE>
  Reads a 4 byte complex 2D array of unknown size into an allocatable 
  array.
  Reads an 8 byte complex 2D array of unknown size into an allocatable 
  array. 
  Reads in a 1 byte integer 2D array of unknown size into an allocatable
  array.
<A NAME="subroutine_loadtxt_dynamic_i2"><H3>loadtxt_dynamic_i2</H3></A>
<PRE>private subroutine loadtxt_dynamic_i2 (filename, i2array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    integer (kind=int16), allocatable, dimension(:,:), intent(inout) :: i2array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber'  
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_i2
</PRE>
  Reads in a 2 byte integer 2D array of unknown size into an allocatable 
  array.
<A NAME="subroutine_loadtxt_dynamic_i4"><H3>loadtxt_dynamic_i4</H3></A>
<PRE>private subroutine loadtxt_dynamic_i4 (filename, i4array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    integer (kind=int32), allocatable, dimension(:,:), intent(inout) :: i4array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber' 
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_i4
</PRE>
  Reads in a 4 byte integer 2D array of unknown size into an allocatable !!  array
<A NAME="subroutine_loadtxt_dynamic_i8"><H3>loadtxt_dynamic_i8</H3></A>
<PRE>private subroutine loadtxt_dynamic_i8 (filename, i8array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    integer (kind=int64), allocatable, dimension(:,:), intent(inout) :: i8array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber' 
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_i8
</PRE>
  Reads in an 8 byte integer 2D array of unknown size into an 
  allocatable array.
<A NAME="subroutine_loadtxt_dynamic_r4"><H3>loadtxt_dynamic_r4</H3></A>
<PRE>private subroutine loadtxt_dynamic_r4 (filename, r4array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    real (kind=real32), allocatable, dimension(:,:), intent(inout) :: r4array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber' 
 (produce error if array allocated), and 'append' (append data to  
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_r4
</PRE>
  Reads in a single precision 2D array of unknown size into an 
 allocatable array.
<A NAME="subroutine_loadtxt_dynamic_r8"><H3>loadtxt_dynamic_r8</H3></A>
<PRE>private subroutine loadtxt_dynamic_r8 (filename, r8array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    real (kind=real64), allocatable, dimension(:,:), intent(inout) :: r8array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber' 
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_r8
</PRE>
  Reads in a double precision 2D array of unknown size into an 
  allocatable array.
<A NAME="subroutine_loadtxt_dynamic_r16"><H3>loadtxt_dynamic_r16</H3></A>
<PRE>private subroutine loadtxt_dynamic_r16 (filename, r16array_dyn, clobber, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    real (kind=real128), allocatable, dimension(:,:), intent(inout) :: r16array_dyn
</PRE>
<DL><DD><DL><DD>
 The allocatable array which is to be filled with data read in from 
 the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite array if already allocated. Options 
 are 'clobber' (overwrite array if allocated, default), 'noclobber' 
 (produce error if array allocated), and 'append' (append data to 
 array if already allocated).
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>    ! Calls: file_size
end subroutine loadtxt_dynamic_r16
</PRE>
  Reads in a 16 byte 2D real array of unknown size into an allocatable 
  array.
<A NAME="subroutine_loadtxt_static_i1"><H3>loadtxt_static_i1</H3></A>
<PRE>private subroutine loadtxt_static_i1 (filename, i1array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array.
</DL></DL>
<PRE>    integer (kind=int8), dimension(:,:), intent(out) :: i1array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_i1
</PRE>
  Reads in an 8 byte complex 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
 because the array was too small.
  Reads in a 16 byte complex 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
  Reads in a 1 byte integer 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_i2"><H3>loadtxt_static_i2</H3></A>
<PRE>private subroutine loadtxt_static_i2 (filename, i2array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    integer (kind=int16), dimension(:,:), intent(out) :: i2array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_i2
</PRE>
  Reads in a 2 byte integer 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_i4"><H3>loadtxt_static_i4</H3></A>
<PRE>private subroutine loadtxt_static_i4 (filename, i4array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    integer (kind=int32), dimension(:,:), intent(out) :: i4array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_i4
</PRE>
  Reads in a 4 byte integer 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_i8"><H3>loadtxt_static_i8</H3></A>
<PRE>private subroutine loadtxt_static_i8 (filename, i8array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    integer (kind=int64), dimension(:,:), intent(out) :: i8array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_i8
</PRE>
  Reads in an 8 byte integer 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_r4"><H3>loadtxt_static_r4</H3></A>
<PRE>private subroutine loadtxt_static_r4 (filename, r4array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    real (kind=real32), dimension(:,:), intent(out) :: r4array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_r4
</PRE>
  Reads in a single precision 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_r8"><H3>loadtxt_static_r8</H3></A>
<PRE>private subroutine loadtxt_static_r8 (filename, r8array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    real (kind=real64), dimension(:,:), intent(out) :: r8array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_r8
</PRE>
  Reads in a double precision 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_loadtxt_static_r16"><H3>loadtxt_static_r16</H3></A>
<PRE>private subroutine loadtxt_static_r16 (filename, r16array, nrows, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file from which to read in the array. 
</DL></DL>
<PRE>    real (kind=real128), dimension(:,:), intent(out) :: r16array
</PRE>
<DL><DD><DL><DD>
 The array which is to be filled with values read in from the file.
</DL></DL>
<PRE>    integer, intent(out) :: nrows
</PRE>
<DL><DD><DL><DD>
 Returns the number of rows of data which were read into the array.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine loadtxt_static_r16
</PRE>
  Reads in a quad precision 2D array whose dimensions are known in 
  advance. Note that there is no way to know if some data was missed 
  because the array was too small.
<A NAME="subroutine_set_comment"><H3>set_comment</H3></A>
<PRE>private subroutine set_comment (com)
    character, intent(in) :: com
</PRE>
<DL><DD><DL><DD>
 The character which designates the beginning of a comment.
</DL></DL>
<PRE>end subroutine set_comment
</PRE>
  Sets the character which designates a comment in input files.
<A NAME="subroutine_savetxt_i1"><H3>savetxt_i1</H3></A>
<PRE>private subroutine savetxt_i1 (filename, i1array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    integer (kind=int8), dimension(:,:), target, intent(in) :: i1array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_i1
</PRE>
  Writes out an 8 byte complex 2D array.
  Writes out a 16 byte complex 2D array.
  Writes out a 1 byte integer 2D array.
<A NAME="subroutine_savetxt_i2"><H3>savetxt_i2</H3></A>
<PRE>private subroutine savetxt_i2 (filename, i2array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    integer (kind=int16), dimension(:,:), target, intent(in) :: i2array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_i2
</PRE>
  Writes out a 2 byte integer 2D array.
<A NAME="subroutine_savetxt_i4"><H3>savetxt_i4</H3></A>
<PRE>private subroutine savetxt_i4 (filename, i4array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    integer (kind=int32), dimension(:,:), target, intent(in) :: i4array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_i4
</PRE>
  Writes out a 4 byte integer 2D array.
<A NAME="subroutine_savetxt_i8"><H3>savetxt_i8</H3></A>
<PRE>private subroutine savetxt_i8 (filename, i8array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    integer (kind=int64), dimension(:,:), target, intent(in) :: i8array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_i8
</PRE>
  Writes out an 8 byte integer 2D array.
<A NAME="subroutine_savetxt_r4"><H3>savetxt_r4</H3></A>
<PRE>private subroutine savetxt_r4 (filename, r4array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    real (kind=real32), dimension(:,:), target, intent(in) :: r4array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_r4
</PRE>
  Writes out a single precision 2D array.
<A NAME="subroutine_savetxt_r8"><H3>savetxt_r8</H3></A>
<PRE>private subroutine savetxt_r8 (filename, r8array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    real (kind=real64), dimension(:,:), target, intent(in) :: r8array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_r8
</PRE>
  Writes out a double precision 2D array.
<A NAME="subroutine_savetxt_r16"><H3>savetxt_r16</H3></A>
<PRE>private subroutine savetxt_r16 (filename, r16array, clobber, user_format, errval)
    character (len=*), intent(in) :: filename
</PRE>
<DL><DD><DL><DD>
 The file to which to write in the array. If it is 'stdout' then 
 writes to terminal instead of file.
</DL></DL>
<PRE>    real (kind=real128), dimension(:,:), target, intent(in) :: r16array
</PRE>
<DL><DD><DL><DD>
 The array which is to be written to the file.
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: clobber
</PRE>
<DL><DD><DL><DD>
 Determines whether to overwrite existing files. Options are 
 'clobber' (overwrite file if exists, default), 'noclobber' (produce 
 error if file exists), and 'append' (append output to file if 
 exists).
</DL></DL>
<PRE>    character (len=*), optional, intent(in) :: user_format
</PRE>
<DL><DD><DL><DD>
 A format string which can be used to provide a custom specification 
 for the array output.
</DL></DL>
<PRE>    integer, optional, intent(out) :: errval
</PRE>
<DL><DD><DL><DD>
 Returns any error codes generated during the execution of this 
 subroutine.
</DL></DL>
<PRE>end subroutine savetxt_r16
</PRE>
  Writes out a quad precision 2D array.
</HTML>
